#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import os
import glob
import itertools
import math
import numpy as np

EPS = 1e-9

# ---------------- POSCAR IO ----------------

def read_poscar(path):
    """Read VASP POSCAR/CONTCAR (supports VASP5 symbols, Selective, Direct/Cartesian)."""
    with open(path, "r", encoding="utf-8") as f:
        lines = [ln.rstrip("\n") for ln in f]

    if len(lines) < 8:
        raise ValueError("POSCAR too short / invalid.")

    comment = lines[0].strip()
    scale = float(lines[1].split()[0])

    # lattice vectors as rows (a,b,c)
    lat_rows = []
    for i in range(2, 5):
        lat_rows.append([float(x) for x in lines[i].split()[:3]])
    lat_rows = np.array(lat_rows, dtype=float) * scale  # Å

    idx = 5
    tokens = lines[idx].split()
    has_symbols = any(any(c.isalpha() for c in tok) for tok in tokens)

    if has_symbols:
        symbols = tokens
        idx += 1
        counts = [int(x) for x in lines[idx].split()]
        idx += 1
    else:
        symbols = None
        counts = [int(x) for x in lines[idx].split()]
        idx += 1

    selective = False
    if lines[idx].strip().lower().startswith("s"):
        selective = True
        idx += 1

    coord_type = lines[idx].strip().lower()
    if coord_type.startswith("d"):
        mode = "Direct"
    elif coord_type.startswith("c") or coord_type.startswith("k"):
        mode = "Cartesian"
    else:
        raise ValueError(f"Unknown coordinate mode line: {lines[idx]}")
    idx += 1

    n = sum(counts)
    coords = []
    flags = []
    for i in range(n):
        parts = lines[idx + i].split()
        if len(parts) < 3:
            raise ValueError(f"Invalid coordinate line: {lines[idx+i]}")
        coords.append([float(parts[0]), float(parts[1]), float(parts[2])])
        if selective and len(parts) >= 6:
            flags.append(parts[3:6])
        else:
            flags.append(None)

    coords = np.array(coords, dtype=float)

    return {
        "comment": comment,
        "symbols": symbols,
        "counts": counts,
        "lattice_rows": lat_rows,
        "selective": selective,
        "mode": mode,
        "coords": coords,
        "flags": flags,
    }

def write_vasp5(path, comment, lattice_rows, symbols, counts, frac_coords,
               selective=False, flags=None):
    """Write VASP5 POSCAR with Direct coords and scale=1.0."""
    if symbols is None:
        # if original file lacks symbols, keep placeholder
        symbols = ["X"] * len(counts)

    with open(path, "w", encoding="utf-8") as f:
        f.write(f"{comment}\n")
        f.write(f"{1.0:.16f}\n")
        for i in range(3):
            f.write(f"{lattice_rows[i,0]:.16f} {lattice_rows[i,1]:.16f} {lattice_rows[i,2]:.16f}\n")
        f.write(" ".join(symbols) + "\n")
        f.write(" ".join(str(x) for x in counts) + "\n")
        if selective:
            f.write("Selective dynamics\n")
        f.write("Direct\n")
        for i, v in enumerate(frac_coords):
            line = f"{v[0]:.16f} {v[1]:.16f} {v[2]:.16f}"
            if selective and flags and flags[i] is not None:
                line += " " + " ".join(flags[i])
            f.write(line + "\n")

# ---------------- Other format writers ----------------

def lattice_to_cell_params(lattice_rows):
    a = lattice_rows[0]
    b = lattice_rows[1]
    c = lattice_rows[2]
    la = np.linalg.norm(a)
    lb = np.linalg.norm(b)
    lc = np.linalg.norm(c)

    def angle(u, v):
        cuv = np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v))
        cuv = max(-1.0, min(1.0, cuv))
        return math.degrees(math.acos(cuv))

    alpha = angle(b, c)
    beta  = angle(a, c)
    gamma = angle(a, b)
    return la, lb, lc, alpha, beta, gamma

def sanitize_cif_name(s):
    out = []
    for ch in s:
        if ch.isalnum() or ch == "_":
            out.append(ch)
        else:
            out.append("_")
    return ("".join(out)[:60] or "structure")

def expand_species(symbols, counts):
    if symbols is None:
        symbols = ["X"] * len(counts)
    species = []
    for s, n in zip(symbols, counts):
        species += [s] * n
    return species, symbols

def write_xyz(path, symbols, counts, lattice_rows, frac_coords):
    species, _ = expand_species(symbols, counts)
    A = lattice_rows.T  # columns a,b,c
    cart = (A @ frac_coords.T).T

    with open(path, "w", encoding="utf-8") as f:
        f.write(f"{len(species)}\n")
        f.write("Generated by batch_vesta_transform.py\n")
        for sp, r in zip(species, cart):
            f.write(f"{sp} {r[0]:.16f} {r[1]:.16f} {r[2]:.16f}\n")

def write_cif(path, name, symbols, counts, lattice_rows, frac_coords):
    species, _ = expand_species(symbols, counts)
    la, lb, lc, alpha, beta, gamma = lattice_to_cell_params(lattice_rows)

    with open(path, "w", encoding="utf-8") as f:
        f.write(f"data_{sanitize_cif_name(name)}\n")
        f.write("_symmetry_space_group_name_H-M   'P 1'\n")
        f.write("_symmetry_Int_Tables_number      1\n")
        f.write("loop_\n")
        f.write("  _symmetry_equiv_pos_as_xyz\n")
        f.write("  'x, y, z'\n")
        f.write(f"_cell_length_a    {la:.8f}\n")
        f.write(f"_cell_length_b    {lb:.8f}\n")
        f.write(f"_cell_length_c    {lc:.8f}\n")
        f.write(f"_cell_angle_alpha {alpha:.8f}\n")
        f.write(f"_cell_angle_beta  {beta:.8f}\n")
        f.write(f"_cell_angle_gamma {gamma:.8f}\n")
        f.write("loop_\n")
        f.write("  _atom_site_label\n")
        f.write("  _atom_site_type_symbol\n")
        f.write("  _atom_site_fract_x\n")
        f.write("  _atom_site_fract_y\n")
        f.write("  _atom_site_fract_z\n")
        counter = {}
        for sp, v in zip(species, frac_coords):
            counter[sp] = counter.get(sp, 0) + 1
            label = f"{sp}{counter[sp]}"
            f.write(f"  {label} {sp} {v[0]:.8f} {v[1]:.8f} {v[2]:.8f}\n")

# ---------------- VESTA-like Unit Cell Transformation (with filling) ----------------

def frac_from_input(data):
    """Return old fractional coordinates Nx3 from Direct or Cartesian input."""
    R = data["lattice_rows"]          # rows a,b,c
    A = R.T                           # columns a,b,c
    if data["mode"].lower().startswith("d"):
        return data["coords"].copy()
    # Cartesian -> fractional: r = A f
    r = data["coords"]
    f = (np.linalg.inv(A) @ r.T).T
    return f

def wrap01(x):
    return x - np.floor(x)

def in_unit_cell(f):
    """Check f in [0,1) with tolerance."""
    return np.all(f >= -EPS) and np.all(f < 1.0 - EPS)

def dedup_frac(fracs, tol=1e-6):
    """Deduplicate fractional points by rounding."""
    if len(fracs) == 0:
        return fracs
    arr = np.array(fracs, dtype=float)
    key = np.round(arr / tol).astype(np.int64)
    _, idx = np.unique(key, axis=0, return_index=True)
    return arr[np.sort(idx)]

def vesta_transform_fill(f_old, lattice_rows_old, P, p_shift,
                        normalize=True, max_search=None):
    """
    Implements VESTA behavior when det(P)>1:
    - New lattice: (a',b',c') = (a,b,c) P
    - New fractional: f' = P^{-1} (f - p + n), for some integer n
    - Choose n such that f' lies in [0,1) (if normalize)
    - Generate all images needed to fill new cell (atom count * det(P))
    """
    P = np.array(P, dtype=float).reshape(3, 3)
    detP = float(np.linalg.det(P))
    if abs(detP) < 1e-12:
        raise ValueError("det(P)=0, invalid transformation matrix.")
    detP_int = int(round(abs(detP)))
    if detP_int <= 0:
        raise ValueError("Invalid det(P).")

    # New lattice rows: R' = P^T R  (equivalent to (a,b,c)P under row-vector convention)
    R_old = np.array(lattice_rows_old, dtype=float)
    R_new = (P.T @ R_old)

    p = np.array(p_shift, dtype=float).reshape(3)
    Pinv = np.linalg.inv(P)

    out_fracs = []

    if not normalize:
        # If not normalizing, just transform the principal point (n=0)
        # and do not fill the cell.
        for f in f_old:
            base = f - p
            fp = (Pinv @ base.reshape(3, 1)).reshape(3)
            out_fracs.append(fp)
        out_fracs = np.array(out_fracs, dtype=float)
        return R_new, out_fracs, detP_int

    # For normalize=True, calculate efficient search bounds for n
    # n_k roughly in [Sum(min(0, Pkj)) - 1, Sum(max(0, Pkj)) + 1]
    mins = np.sum(np.minimum(0, P), axis=1)
    maxs = np.sum(np.maximum(0, P), axis=1)

    ranges = []
    for k in range(3):
        low = int(np.floor(mins[k] - 1.0))
        high = int(np.ceil(maxs[k] + 1.0))
        ranges.append(range(low, high + 1))

    # Pre-calculate transformed shifts: S = Pinv @ n
    shifts = list(itertools.product(*ranges))
    shifts_arr = np.array(shifts, dtype=float).T  # 3 x N_shifts
    S = (Pinv @ shifts_arr).T                     # N_shifts x 3

    # Vectorized processing per atom
    for f in f_old:
        base = f - p
        fb = (Pinv @ base.reshape(3, 1)).reshape(3)

        # Check all shifts: candidates = fb + S
        candidates = fb + S

        # in_unit_cell logic vectorized
        # [0, 1) with EPS tolerance
        mask = np.all((candidates >= -EPS) & (candidates < 1.0 - EPS), axis=1)
        valid_fps = candidates[mask]

        for fp in valid_fps:
            out_fracs.append(fp)

    out_fracs = dedup_frac(out_fracs, tol=1e-6)
    return R_new, out_fracs, detP_int

def scale_counts(counts, factor):
    return [int(c * factor) for c in counts]

# ---------------- CLI ----------------

def parse_matrix_arg(s):
    rows = s.strip().split(";")
    if len(rows) != 3:
        raise ValueError("Matrix must have 3 rows separated by ';'")
    mat = []
    for r in rows:
        r = r.replace(",", " ").split()
        if len(r) != 3:
            raise ValueError("Each row must have 3 numbers.")
        mat.append([float(x) for x in r])
    return mat

def main():
    examples = r"""
Examples
--------
1) Interactive input (matrix & shift prompted), batch on stru/ -> out/:
   python3 batch_vesta_transform.py

2) Provide matrix & shift directly, output vasp5+cif+xyz:
   python3 batch_vesta_transform.py \
     --in_dir stru --out_dir out \
     --P "-1 2 0; -2 -1 0; 0 0 1" \
     --shift "0 0 0" \
     --formats vasp5,cif,xyz

3) Only output CIF, and do not normalize (NOT recommended for det(P)>1):
   python3 batch_vesta_transform.py \
     --P "-1 2 0; -2 -1 0; 0 0 1" \
     --formats cif \
     --no-normalize

4) Only process *.vasp in stru/:
   python3 batch_vesta_transform.py \
     --pattern "*.vasp" \
     --P "-1 2 0; -2 -1 0; 0 0 1"

Matrix format
-------------
P must be 3x3, written in ONE line with ';' separating rows:
   --P "p11 p12 p13; p21 p22 p23; p31 p32 p33"

Origin shift
------------
--shift is a fractional vector (VESTA 'Origin shift p') in the OLD cell:
   --shift "px py pz"
"""

    ap = argparse.ArgumentParser(
        prog="batch_vesta_transform.py",
        description=(
            "VESTA-like Unit Cell Transformation for VASP POSCAR with proper filling when det(P)>1.\n"
            "It prints new lattice vectors a', b', c', and batch-processes files in in_dir."
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=examples,
    )

    ap.add_argument("--in_dir", default="stru", help="Input folder (default: stru)")
    ap.add_argument("--out_dir", default="out", help="Output folder (default: out)")
    ap.add_argument("--pattern", default="*", help='Glob pattern in in_dir (default: "*"), e.g. "*.vasp"')
    ap.add_argument("--P", default=None,
                    help='3x3 matrix in one line, e.g. --P "-1 2 0; -2 -1 0; 0 0 1"')
    ap.add_argument("--shift", default=None,
                    help='Origin shift p in fractional coords, e.g. --shift "0 0 0" (default: 0 0 0)')
    ap.add_argument("--no-normalize", action="store_true",
                    help="Do NOT normalize into [0,1). (For det(P)>1, this will NOT fill the new cell.)")
    ap.add_argument("--formats", default="vasp5,cif,xyz",
                    help="Comma-separated outputs: vasp5,cif,xyz (default: vasp5,cif,xyz)")
    ap.add_argument("--max_search", type=int, default=None,
                    help="Search bound for integer translations (advanced). Larger if you miss atoms.")

    args = ap.parse_args()

    # matrix & shift
    if args.P is None:
        print("\n请输入 3x3 矩阵 P（一行，用;分行），例如：-1 2 0; -2 -1 0; 0 0 1")
        P = parse_matrix_arg(input("P = ").strip())
    else:
        P = parse_matrix_arg(args.P)

    if args.shift is None:
        s = input("请输入 origin shift p（分数坐标，默认 0 0 0）: ").strip()
        if s == "":
            p_shift = [0.0, 0.0, 0.0]
        else:
            parts = s.replace(",", " ").split()
            if len(parts) != 3:
                raise ValueError("shift must have 3 numbers.")
            p_shift = [float(x) for x in parts]
    else:
        parts = args.shift.replace(",", " ").split()
        if len(parts) != 3:
            raise ValueError("shift must have 3 numbers.")
        p_shift = [float(x) for x in parts]

    normalize = (not args.no_normalize)
    formats = [x.strip().lower() for x in args.formats.split(",") if x.strip()]
    os.makedirs(args.out_dir, exist_ok=True)

    # files
    files = sorted(glob.glob(os.path.join(args.in_dir, args.pattern)))
    files = [p for p in files if os.path.isfile(p)]
    if not files:
        print(f"[WARN] No files found in {args.in_dir} with pattern '{args.pattern}'")
        return

    print("\n=== Transformation ===")
    print("P =")
    for r in P:
        print("  ", r)
    print("shift p (old frac) =", p_shift)
    print("normalize =", normalize)
    print("formats =", formats)
    print("======================\n")

    for fp in files:
        base = os.path.basename(fp)
        name, _ext = os.path.splitext(base)
        try:
            data = read_poscar(fp)
            f_old = frac_from_input(data)

            R_new, f_new, detP_int = vesta_transform_fill(
                f_old=f_old,
                lattice_rows_old=data["lattice_rows"],
                P=P,
                p_shift=p_shift,
                normalize=normalize,
                max_search=args.max_search
            )

            # print new lattice vectors
            print(f"[{base}] det(P) ~ {detP_int}")
            print("  new lattice vectors (rows = a', b', c'):")
            print(f"    a' = {R_new[0,0]: .8f} {R_new[0,1]: .8f} {R_new[0,2]: .8f}")
            print(f"    b' = {R_new[1,0]: .8f} {R_new[1,1]: .8f} {R_new[1,2]: .8f}")
            print(f"    c' = {R_new[2,0]: .8f} {R_new[2,1]: .8f} {R_new[2,2]: .8f}")

            # update counts (if normalize and det>1, we filled the new cell)
            if normalize:
                new_counts = scale_counts(data["counts"], detP_int)
            else:
                new_counts = data["counts"]

            # write outputs
            if "vasp5" in formats or "vasp" in formats:
                outp = os.path.join(args.out_dir, f"{name}.vasp")
                write_vasp5(outp, data["comment"], R_new, data["symbols"], new_counts, f_new)

            if "xyz" in formats:
                outp = os.path.join(args.out_dir, f"{name}.xyz")
                write_xyz(outp, data["symbols"], new_counts, R_new, f_new)

            if "cif" in formats:
                outp = os.path.join(args.out_dir, f"{name}.cif")
                write_cif(outp, name, data["symbols"], new_counts, R_new, f_new)

            print(f"  atoms: {len(f_old)} -> {len(f_new)}")
            print(f"  -> written to {args.out_dir}/\n")

        except Exception as e:
            print(f"[ERROR] {base}: {e}\n")


if __name__ == "__main__":
    main()
